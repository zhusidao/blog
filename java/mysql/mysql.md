## 选择优化的数据类型  

1.更小的统常更好  
2.简单就好  
3  尽量避免NULL
包含可为NULL的列，对Mysql来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。
可为NULL的列会使得等多的存储空间，在Mysql里也需要特殊处理。当可为NULL的列被索引时，每个索引
记录需要一个额外的字节


## 事务隔离级别
**READ UNCOMMITTED(未提交读)**
在这个级别中，事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也叫“脏读”。READ UNCOMMITTED性能也不会比其他的级别好太多。但缺乏其他级别的很多好处，除非真的有必要的理由，但实际应用中一般很少使用。  
**READ COMMITTED(提交读)**
大多数数据库系统的默认隔离级别都是READ COMMITTED(但mysql不是)。READ COMMITTED满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做“不可重复读”，因为两次执行同样的查询，可能会得到不一样的结果。  
**REPEATETABLE READ(可重复读)**
REPEATETABLE READ解决了脏读的问题。该级别保证了同一个事务中多次读取的同样记录的结果是一致的。但理论上，可重复读隔离级别还是无法解决另一个幻读的问题。所谓幻读，指的是当某个事务在读取某个范围的记录时，另一个事务又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行  
**SERIALIZABLE(串行化)**
SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应该用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受并没有并发的情况下，才考虑采用该级别。

##  间隙锁:
间隙锁（Gap Lock）是Innodb在提交下为了解决幻读问题时引入的锁机制，（下面的所有案例没有特意强调都使用可重复读隔离级别）幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock）来实现的。  
加锁规则有以下特性，我们会在后面的案例中逐一解释：  
1.加锁的基本单位是（next-key lock）,他是前开后闭原则  
2.插叙过程中访问的对象会增加锁  
3.索引上的等值查询--给唯一索引加锁的时候，next-key lock升级为行锁  
4.索引上的等值查询--向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁  
5.唯一索引上的范围查询会访问到不满足条件的第一个值为止  
案例数据

id(主键) | c（普通索引）| d（无索引）  
-|-|-
5 | 5 | 5 |
10 | 10 | 10 |
15 | 15 | 15 |
20 | 20 | 20 |
25 | 25 | 25 |

以上数据为了解决幻读问题，更新的时候不只是对上述的五条数据增加行锁，还对于中间的取值范围增加了6间隙锁，（-∞，5]（5，10]（10，15]（15，20]（20，25]（25，+supernum] （其中supernum是数据库维护的最大的值。为了保证间隙锁都是左开右闭原则。）

案例一：间隙锁简单案例

步骤 | 事务A | 事务B
-|-|-
1 | begin;select * from t where id = 11 for update; | - |
2 | - | insert into user value(12,12,12) |
3 | commit; | - | 

当有如下事务A和事务B时，事务A会对数据库表增加（10，15]这个区间锁，这时insert id = 12 的数据的时候就会因为区间锁（10，15]而被锁住无法执行。

案例二： 间隙锁死锁问题

步骤 | 事务A | 事务B
-|-|-
1 | begin;select * from t where id = 9 for update; | - |
2 | - | begin;select * from t where id = 6 for update; |
3 | - | insert into user value(7,7,7) |
4 | insert into user value(7,7,7) | - |

不同于写锁相互之间是互斥的原则，间隙锁之间不是互斥的，如果一个事务A获取到了（5,10]之间的间隙锁，另一个事务B也可以获取到（5,10]之间的间隙锁。这时就可能会发生死锁问题，如下案例。
事务A获取到（5,10]之间的间隙锁不允许其他的DDL操作，在事务提交，间隙锁释放之前，事务B也获取到了间隙锁（5,10]，这时两个事务就处于死锁状态



## 索引使用
1.独立的列
列不能是表达式的一部分，也不能是函数参数    

2.前缀索引
选择前缀索引要降低索引值的重复性，对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，mysql不允许索引这些列的完整长度。
创建前缀索引：alter table city_demo add key (city(7))  
缺点：mysql无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖扫描。
mysql不持支后缀索引

3.多列索引
为每个列创建独立的索引，或者按照错误的顺序创建多列索引。
ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);
注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。 

最左前缀：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。

注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

4.

5.聚簇索引



6.覆盖索引
如果一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’。即只需扫描索引而无须回表。
只扫描索引而无需回表的优点：
    1.索引条目通常远小于数据行大小，只需要读取索引，则mysql会极大地减少数据访问量。
    2.因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很多。
    3.一些存储引擎如myisam在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用
    4.innodb的聚簇索引，覆盖索引对innodb表特别有用。(innodb的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询)

7.索引排序
mysql有两种方式生成有序的结果:通过排序操作；或者按索引顺序扫描。

如果EXPLAN出来的type列的值为“index”，则说明mysql使用了索引扫描来做排序(不要和extra列的“Using index”搞混淆了)。

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

只有当索引列顺序和order by子句的顺序完全一致，并且所有列的排序方向(倒序或者正序)都一样时，mysql才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当order by子句引用的字段全部为第一张表时，才能使用索引做排序。order by子句和查找型查询的限制是一样的: 需要满足索引的最左前缀要求; 否则，mysql都需要执行排序操作，无法利用索引排序。

例子说明: 
KEY a_b_c(a,b,c)
1.order by 能使用索引最做前缀
- ORDER BY a
- ORDER BY a,b
- ORDER BY a,b,c
- ORDER BY a DESC,b DESC,c DESC

2.如果WHERE使用索引的最左前缀定义为常量,则ORDER BY 能使用索引
-WHERE a = const  ORDER BY b,c
-WHERE a = const AND b = const ORDER BY c
-WHERE a = const  ORDER BY b,c
-WHERE a = const AND b > const ORDER BY b,c

3.不能使用索引排序
-ORDER BY a ASC,b DESC,c DESC /*排序不一致*/
-WHERE g = const ORDER BY b,c    /*丢失a索引*/
-WHERE a = const ORDER BY c     /*丢失b索引*/
-WHERE a = const ORDER BY a,d /*d不是索引的一部分*/
-WHERE a in(...) ORDER BY b,c /*对于排序来说,多个相等的条件也是范围查询*/

8.



## 查询性能优化
查询性能低最基本的原因是访问的数据太多，某些查询可能不可避免地需要晒选大量数据，但这并不常见。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效。
1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行。但有时候也可能访问了太多的列。
1.查询不需要记录
2.多表关联时返回全部列
3.总是去除全部列

2.确认mysql服务器层是否在分析大量超过需要的数据行。



