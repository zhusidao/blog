#### **jvm内存划分图**

1.6及其以前

![img](https://img-blog.csdnimg.cn/img_convert/57245ed7e223b9ba6f86b3efe9e761a8.png)

**程序计数器：**当前线程所执行的字节码的行号指示器，也即将将要执行的指令代码。（**唯一一个没有规定任何OOM**）

**栈：**每个方法执行的同时都创建一个栈帧，用于存储局部变量表（基本类型、应用类型）、操作数栈、动态链接、方法出口等。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程

**本地方法栈：**虚拟机使用到的Native方法服务。

**堆：**存放对象实例，几乎所有的对象都在这里完成内存分配

**方法区：**用与储存已被虚拟机加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据

**运行常量池：**用户存放编译期间生成的各种字面亮和符号引用，。

**直接内存：**不属于jvm一部分。NIO引入了一种基于通道(channel)与缓冲区(buffer)的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。提高性能，避免了在java堆和Native堆中来回复制数据。

1.8之后







#### **判断对象是否可以被回收**

存在任何一条引用链到达GC ROOT

**固定可作为GC Roots的对象**

1.·在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

2.在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量

3.在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用

4.本地方法栈中JNI（即一般说Native方法）引用的对象

5.所有被同步锁(synchronized关键字)持有的对象

6.Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如

NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。

7.反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等





#### 四种引用

**强引用**在程序代码中普遍存在，类似Object obj = new Object()，这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**软引用**是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出的异常值钱，将会把这些对象进行范围之中的回收。如果这次回收还没有足够的内存，机会抛出内存溢出异常。

**弱引用**也是用来非必须对象的，但是它的强度比软引用更弱一些，关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

**虚引用**是最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾回收时收到一个系统通知。



#### 垃圾回收算法

**标记清除：**分为"标记"和"清除"俩个阶段：首先标记所有需要收回的对象，然后进行统一清楚
特点：标记和清除效率都不高，会产生内存碎片

**复制：**按内存大小划分为大小相等的两块，每次就使用其中的一块。当一块内存用完了，将还存活着的对象复制到另一块上去，然后再把已经使用的内存空间一次清理掉。
特点：实现简单，运行高效，可用内存缩小一半
改进：划分内存为一块Eden，两块Survivor，比例为8:1。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor还存活的对象一次性复制到另一块Survivor空间上，足后清理Eden和刚用过的Survivor空间，改进后的复制算法用于回收新生代。

**标记整理：**和"标记-清除"一样，但是后续不是直接对可回收内存进行清理，而是让存活的对象都像一端移动，然后直接清理掉端边界以外的内存，老年代选用这种算法。

**分代收集：**根据对象存活的周期将内存划分为几块，一般是把堆划分为新生代和老年代，根据各个年代特点选择最适当的收集算法。新生代有大量的对象死去，只有少量存活，采用复制算法，只需要少量存活对象复制成本就可以完成收集。老年代存活率高、没有额外空间对它进行担保，就需要采用"标记-清除"或"标记-整理"算法来进行收集。



#### 收集器





#### 内存分配以及GC

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

**大对象**就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。

在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易 导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复 制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了-XX:PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区 之间来回复制，产生大量的内存复制操作。

**长期存活的对象将进入老年代：**对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程 度(默认为15)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。

**动态对象年龄判定：**为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX:MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX:MaxTenuringThreshold中要求的年龄。

**空间分配担保**：在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看- XX:HandlePromotionFailure参数的设置值是否允许担保失败(Handle Promotion Failure);如果允 许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大 于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的（Minor GC后空间还是不够，只能再次Full GC，两次的GC的时间消耗）; 如果小于，或者-XX: HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。